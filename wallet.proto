syntax = "proto3";
option go_package = "github.com/tdex-network/tdex-protobuf/generated/go/wallet";

/**
 * Service for Liquidity Providers to manage funds via walle RPC
 */
service Wallet {
  /*
  GenSeed is the first method that should be used to instantiate a new lnd
  instance. This method allows a caller to generate a new BIP44 HD Wallet.
  If provided, the passphrase will be necessary
  to decrypt the cipherseed to expose the internal wallet seed.
  Once the cipherseed is obtained and verified by the user, the InitWallet
  method should be used to commit the newly generated seed, and create the
  wallet.
  */
  rpc GenSeed(GenSeedRequest) returns (GenSeedResponse);

  /*
  InitWallet is used when lnd is starting up for the first time to fully
  initialize the daemon and its internal wallet. At the very least a wallet
  password must be provided. This will be used to encrypt sensitive material
  on disk.
  In the case of a recovery scenario, the user can also specify their
  mnemonic and passphrase. If set, then the daemon will use this prior state
  to initialize its internal wallet.
  Alternatively, this can be used along with the GenSeed RPC to obtain a
  seed, then present it to the user. Once it has been verified by the user,
  the seed can be fed into this RPC in order to commit the new wallet.
  */
  rpc InitWallet(InitWalletRequest) returns (InitWalletResponse);

  /*
  UnlockWallet is used at startup of lnd to provide a password to unlock
  the wallet database.
  */
  rpc UnlockWallet(UnlockWalletRequest) returns (UnlockWalletResponse);

  /*
  ChangePassword changes the password of the encrypted wallet. This will
  automatically unlock the wallet database if successful.
  */
  rpc ChangePassword(ChangePasswordRequest) returns (ChangePasswordResponse);

  /*
  SendToMany sends funds to many outputs
  */
  rpc SendToMany(SendToManyRequest) returns (SendToManyReply);
}

message GenSeedRequest {
  /*
  passphrase is an optional user provided passphrase that will be used
  to encrypt the generated seed.
  */
  bytes passphrase = 1;
}
message GenSeedResponse {
  /*
  seed_mnemonic is a 24-word mnemonic that encodes a prior seed obtained
  by the user. This field is optional, as if not provided, then the daemon will
  generate a new cipher seed for the user. Otherwise, then the daemon will
  attempt to recover the wallet state linked to this cipher seed.
  */
  repeated string seed_mnemonic = 1;
}

message InitWalletRequest {
  /*
  wallet_password is the passphrase that should be used to encrypt the
  wallet. This MUST be at least 8 chars in length. After creation, this
  password is required to unlock the daemon.
  */
  bytes wallet_password = 1;

  /*
  seed_mnemonic is a 24-word mnemonic that encodes a prior seed obtained by the
  user. This MUST be a generated by the GenSeed method
  */
  repeated string seed_mnemonic = 2;
}
message InitWalletResponse {}

message UnlockWalletRequest {
  /*
  wallet_password should be the current valid passphrase for the daemon. This
  will be required to decrypt on-disk material that the daemon requires to
  function properly.
  */
  bytes wallet_password = 1;
}
message UnlockWalletResponse {}

message ChangePasswordRequest {
  /*
  current_password should be the current valid passphrase used to unlock the
  daemon.
  */
  bytes current_password = 1;

  /*
  new_password should be the new passphrase that will be needed to unlock the
  daemon.
  */
  bytes new_password = 2;
}
message ChangePasswordResponse {}

message SendToManyRequest {
  /*
  A slice of the outputs that should be created in the transaction produced.
  */
  repeated TxOut outputs = 1;
  /*
   The number of satoshis per kilo weight that should be used when crafting
   this transaction.
   */
  int64 sat_per_kw = 2;

  // Optional: if true the transaction will be pushed to the network
  bool push = 3;
}

message SendToManyReply {
  /*
    The serialized transaction sent out on the network.
    */
  bytes raw_tx = 1;
}

message TxOut {
  string asset = 1;
  // The value of the output being spent.
  int64 value = 2;
  // The script of the output being spent.
  bytes script = 3;
}