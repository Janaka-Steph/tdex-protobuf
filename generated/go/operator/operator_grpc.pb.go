// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package operator

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// OperatorClient is the client API for Operator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OperatorClient interface {
	// Returns a new derived address for the given market.
	// If market field is empty, a new Market is created and MUST be initialized.
	DepositMarket(ctx context.Context, in *DepositMarketRequest, opts ...grpc.CallOption) (*DepositMarketReply, error)
	// Returns the list of previously generated addresses for the given market.
	ListDepositMarket(ctx context.Context, in *ListDepositMarketRequest, opts ...grpc.CallOption) (*ListDepositMarketReply, error)
	// Returns a new derived address from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	DepositFeeAccount(ctx context.Context, in *DepositFeeAccountRequest, opts ...grpc.CallOption) (*DepositFeeAccountReply, error)
	// Returns the aggregated balance of LBTC held in the fee account.
	BalanceFeeAccount(ctx context.Context, in *BalanceFeeAccountRequest, opts ...grpc.CallOption) (*BalanceFeeAccountReply, error)
	// Makes the given market tradable
	OpenMarket(ctx context.Context, in *OpenMarketRequest, opts ...grpc.CallOption) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale
	CloseMarket(ctx context.Context, in *CloseMarketRequest, opts ...grpc.CallOption) (*CloseMarketReply, error)
	// Get extended details for each markets either open, closed or to be funded.
	ListMarket(ctx context.Context, in *ListMarketRequest, opts ...grpc.CallOption) (*ListMarketReply, error)
	// Changes the Liquidity Provider fee for the given market. I thsould be
	// express in basis point. To change the fee on each swap from (current) 0.25%
	// to 1% you need to pass down 100 The Market MUST be closed before doing this
	// change.
	UpdateMarketFee(ctx context.Context, in *UpdateMarketFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error)
	// Manually updates the price for the given market
	UpdateMarketPrice(ctx context.Context, in *UpdateMarketPriceRequest, opts ...grpc.CallOption) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed
	UpdateMarketStrategy(ctx context.Context, in *UpdateMarketStrategyRequest, opts ...grpc.CallOption) (*UpdateMarketStrategyReply, error)
	// WithdrawMarket allows the operator to withdraw to external wallet funds
	// from a specific market. The Market MUST be closed before doing this change.
	WithdrawMarket(ctx context.Context, in *WithdrawMarketRequest, opts ...grpc.CallOption) (*WithdrawMarketReply, error)
	// Returs all the swaps processed by the daemon (both attempted and completed)
	ListSwaps(ctx context.Context, in *ListSwapsRequest, opts ...grpc.CallOption) (*ListSwapsReply, error)
	// Displays a report on how much the given market is collecting in Liquidity
	// Provider fees
	ReportMarketFee(ctx context.Context, in *ReportMarketFeeRequest, opts ...grpc.CallOption) (*ReportMarketFeeReply, error)
}

type operatorClient struct {
	cc grpc.ClientConnInterface
}

func NewOperatorClient(cc grpc.ClientConnInterface) OperatorClient {
	return &operatorClient{cc}
}

var operatorDepositMarketStreamDesc = &grpc.StreamDesc{
	StreamName: "DepositMarket",
}

func (c *operatorClient) DepositMarket(ctx context.Context, in *DepositMarketRequest, opts ...grpc.CallOption) (*DepositMarketReply, error) {
	out := new(DepositMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/DepositMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorListDepositMarketStreamDesc = &grpc.StreamDesc{
	StreamName: "ListDepositMarket",
}

func (c *operatorClient) ListDepositMarket(ctx context.Context, in *ListDepositMarketRequest, opts ...grpc.CallOption) (*ListDepositMarketReply, error) {
	out := new(ListDepositMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/ListDepositMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorDepositFeeAccountStreamDesc = &grpc.StreamDesc{
	StreamName: "DepositFeeAccount",
}

func (c *operatorClient) DepositFeeAccount(ctx context.Context, in *DepositFeeAccountRequest, opts ...grpc.CallOption) (*DepositFeeAccountReply, error) {
	out := new(DepositFeeAccountReply)
	err := c.cc.Invoke(ctx, "/Operator/DepositFeeAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorBalanceFeeAccountStreamDesc = &grpc.StreamDesc{
	StreamName: "BalanceFeeAccount",
}

func (c *operatorClient) BalanceFeeAccount(ctx context.Context, in *BalanceFeeAccountRequest, opts ...grpc.CallOption) (*BalanceFeeAccountReply, error) {
	out := new(BalanceFeeAccountReply)
	err := c.cc.Invoke(ctx, "/Operator/BalanceFeeAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorOpenMarketStreamDesc = &grpc.StreamDesc{
	StreamName: "OpenMarket",
}

func (c *operatorClient) OpenMarket(ctx context.Context, in *OpenMarketRequest, opts ...grpc.CallOption) (*OpenMarketReply, error) {
	out := new(OpenMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/OpenMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorCloseMarketStreamDesc = &grpc.StreamDesc{
	StreamName: "CloseMarket",
}

func (c *operatorClient) CloseMarket(ctx context.Context, in *CloseMarketRequest, opts ...grpc.CallOption) (*CloseMarketReply, error) {
	out := new(CloseMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/CloseMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorListMarketStreamDesc = &grpc.StreamDesc{
	StreamName: "ListMarket",
}

func (c *operatorClient) ListMarket(ctx context.Context, in *ListMarketRequest, opts ...grpc.CallOption) (*ListMarketReply, error) {
	out := new(ListMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/ListMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorUpdateMarketFeeStreamDesc = &grpc.StreamDesc{
	StreamName: "UpdateMarketFee",
}

func (c *operatorClient) UpdateMarketFee(ctx context.Context, in *UpdateMarketFeeRequest, opts ...grpc.CallOption) (*UpdateMarketFeeReply, error) {
	out := new(UpdateMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorUpdateMarketPriceStreamDesc = &grpc.StreamDesc{
	StreamName: "UpdateMarketPrice",
}

func (c *operatorClient) UpdateMarketPrice(ctx context.Context, in *UpdateMarketPriceRequest, opts ...grpc.CallOption) (*UpdateMarketPriceReply, error) {
	out := new(UpdateMarketPriceReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorUpdateMarketStrategyStreamDesc = &grpc.StreamDesc{
	StreamName: "UpdateMarketStrategy",
}

func (c *operatorClient) UpdateMarketStrategy(ctx context.Context, in *UpdateMarketStrategyRequest, opts ...grpc.CallOption) (*UpdateMarketStrategyReply, error) {
	out := new(UpdateMarketStrategyReply)
	err := c.cc.Invoke(ctx, "/Operator/UpdateMarketStrategy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorWithdrawMarketStreamDesc = &grpc.StreamDesc{
	StreamName: "WithdrawMarket",
}

func (c *operatorClient) WithdrawMarket(ctx context.Context, in *WithdrawMarketRequest, opts ...grpc.CallOption) (*WithdrawMarketReply, error) {
	out := new(WithdrawMarketReply)
	err := c.cc.Invoke(ctx, "/Operator/WithdrawMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorListSwapsStreamDesc = &grpc.StreamDesc{
	StreamName: "ListSwaps",
}

func (c *operatorClient) ListSwaps(ctx context.Context, in *ListSwapsRequest, opts ...grpc.CallOption) (*ListSwapsReply, error) {
	out := new(ListSwapsReply)
	err := c.cc.Invoke(ctx, "/Operator/ListSwaps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var operatorReportMarketFeeStreamDesc = &grpc.StreamDesc{
	StreamName: "ReportMarketFee",
}

func (c *operatorClient) ReportMarketFee(ctx context.Context, in *ReportMarketFeeRequest, opts ...grpc.CallOption) (*ReportMarketFeeReply, error) {
	out := new(ReportMarketFeeReply)
	err := c.cc.Invoke(ctx, "/Operator/ReportMarketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OperatorService is the service API for Operator service.
// Fields should be assigned to their respective handler implementations only before
// RegisterOperatorService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type OperatorService struct {
	// Returns a new derived address for the given market.
	// If market field is empty, a new Market is created and MUST be initialized.
	DepositMarket func(context.Context, *DepositMarketRequest) (*DepositMarketReply, error)
	// Returns the list of previously generated addresses for the given market.
	ListDepositMarket func(context.Context, *ListDepositMarketRequest) (*ListDepositMarketReply, error)
	// Returns a new derived address from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	DepositFeeAccount func(context.Context, *DepositFeeAccountRequest) (*DepositFeeAccountReply, error)
	// Returns the aggregated balance of LBTC held in the fee account.
	BalanceFeeAccount func(context.Context, *BalanceFeeAccountRequest) (*BalanceFeeAccountReply, error)
	// Makes the given market tradable
	OpenMarket func(context.Context, *OpenMarketRequest) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale
	CloseMarket func(context.Context, *CloseMarketRequest) (*CloseMarketReply, error)
	// Get extended details for each markets either open, closed or to be funded.
	ListMarket func(context.Context, *ListMarketRequest) (*ListMarketReply, error)
	// Changes the Liquidity Provider fee for the given market. I thsould be
	// express in basis point. To change the fee on each swap from (current) 0.25%
	// to 1% you need to pass down 100 The Market MUST be closed before doing this
	// change.
	UpdateMarketFee func(context.Context, *UpdateMarketFeeRequest) (*UpdateMarketFeeReply, error)
	// Manually updates the price for the given market
	UpdateMarketPrice func(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed
	UpdateMarketStrategy func(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error)
	// WithdrawMarket allows the operator to withdraw to external wallet funds
	// from a specific market. The Market MUST be closed before doing this change.
	WithdrawMarket func(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error)
	// Returs all the swaps processed by the daemon (both attempted and completed)
	ListSwaps func(context.Context, *ListSwapsRequest) (*ListSwapsReply, error)
	// Displays a report on how much the given market is collecting in Liquidity
	// Provider fees
	ReportMarketFee func(context.Context, *ReportMarketFeeRequest) (*ReportMarketFeeReply, error)
}

func (s *OperatorService) depositMarket(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.DepositMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/DepositMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.DepositMarket(ctx, req.(*DepositMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) listDepositMarket(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDepositMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ListDepositMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/ListDepositMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ListDepositMarket(ctx, req.(*ListDepositMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) depositFeeAccount(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositFeeAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.DepositFeeAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/DepositFeeAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.DepositFeeAccount(ctx, req.(*DepositFeeAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) balanceFeeAccount(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceFeeAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.BalanceFeeAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/BalanceFeeAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.BalanceFeeAccount(ctx, req.(*BalanceFeeAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) openMarket(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.OpenMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/OpenMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.OpenMarket(ctx, req.(*OpenMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) closeMarket(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.CloseMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/CloseMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.CloseMarket(ctx, req.(*CloseMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) listMarket(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ListMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/ListMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ListMarket(ctx, req.(*ListMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) updateMarketFee(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.UpdateMarketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/UpdateMarketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.UpdateMarketFee(ctx, req.(*UpdateMarketFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) updateMarketPrice(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.UpdateMarketPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/UpdateMarketPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.UpdateMarketPrice(ctx, req.(*UpdateMarketPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) updateMarketStrategy(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMarketStrategyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.UpdateMarketStrategy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/UpdateMarketStrategy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.UpdateMarketStrategy(ctx, req.(*UpdateMarketStrategyRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) withdrawMarket(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawMarketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.WithdrawMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/WithdrawMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.WithdrawMarket(ctx, req.(*WithdrawMarketRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) listSwaps(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSwapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ListSwaps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/ListSwaps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ListSwaps(ctx, req.(*ListSwapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *OperatorService) reportMarketFee(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportMarketFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ReportMarketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/Operator/ReportMarketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ReportMarketFee(ctx, req.(*ReportMarketFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterOperatorService registers a service implementation with a gRPC server.
func RegisterOperatorService(s grpc.ServiceRegistrar, srv *OperatorService) {
	srvCopy := *srv
	if srvCopy.DepositMarket == nil {
		srvCopy.DepositMarket = func(context.Context, *DepositMarketRequest) (*DepositMarketReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method DepositMarket not implemented")
		}
	}
	if srvCopy.ListDepositMarket == nil {
		srvCopy.ListDepositMarket = func(context.Context, *ListDepositMarketRequest) (*ListDepositMarketReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ListDepositMarket not implemented")
		}
	}
	if srvCopy.DepositFeeAccount == nil {
		srvCopy.DepositFeeAccount = func(context.Context, *DepositFeeAccountRequest) (*DepositFeeAccountReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method DepositFeeAccount not implemented")
		}
	}
	if srvCopy.BalanceFeeAccount == nil {
		srvCopy.BalanceFeeAccount = func(context.Context, *BalanceFeeAccountRequest) (*BalanceFeeAccountReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method BalanceFeeAccount not implemented")
		}
	}
	if srvCopy.OpenMarket == nil {
		srvCopy.OpenMarket = func(context.Context, *OpenMarketRequest) (*OpenMarketReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method OpenMarket not implemented")
		}
	}
	if srvCopy.CloseMarket == nil {
		srvCopy.CloseMarket = func(context.Context, *CloseMarketRequest) (*CloseMarketReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method CloseMarket not implemented")
		}
	}
	if srvCopy.ListMarket == nil {
		srvCopy.ListMarket = func(context.Context, *ListMarketRequest) (*ListMarketReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ListMarket not implemented")
		}
	}
	if srvCopy.UpdateMarketFee == nil {
		srvCopy.UpdateMarketFee = func(context.Context, *UpdateMarketFeeRequest) (*UpdateMarketFeeReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketFee not implemented")
		}
	}
	if srvCopy.UpdateMarketPrice == nil {
		srvCopy.UpdateMarketPrice = func(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketPrice not implemented")
		}
	}
	if srvCopy.UpdateMarketStrategy == nil {
		srvCopy.UpdateMarketStrategy = func(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method UpdateMarketStrategy not implemented")
		}
	}
	if srvCopy.WithdrawMarket == nil {
		srvCopy.WithdrawMarket = func(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method WithdrawMarket not implemented")
		}
	}
	if srvCopy.ListSwaps == nil {
		srvCopy.ListSwaps = func(context.Context, *ListSwapsRequest) (*ListSwapsReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ListSwaps not implemented")
		}
	}
	if srvCopy.ReportMarketFee == nil {
		srvCopy.ReportMarketFee = func(context.Context, *ReportMarketFeeRequest) (*ReportMarketFeeReply, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ReportMarketFee not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "Operator",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "DepositMarket",
				Handler:    srvCopy.depositMarket,
			},
			{
				MethodName: "ListDepositMarket",
				Handler:    srvCopy.listDepositMarket,
			},
			{
				MethodName: "DepositFeeAccount",
				Handler:    srvCopy.depositFeeAccount,
			},
			{
				MethodName: "BalanceFeeAccount",
				Handler:    srvCopy.balanceFeeAccount,
			},
			{
				MethodName: "OpenMarket",
				Handler:    srvCopy.openMarket,
			},
			{
				MethodName: "CloseMarket",
				Handler:    srvCopy.closeMarket,
			},
			{
				MethodName: "ListMarket",
				Handler:    srvCopy.listMarket,
			},
			{
				MethodName: "UpdateMarketFee",
				Handler:    srvCopy.updateMarketFee,
			},
			{
				MethodName: "UpdateMarketPrice",
				Handler:    srvCopy.updateMarketPrice,
			},
			{
				MethodName: "UpdateMarketStrategy",
				Handler:    srvCopy.updateMarketStrategy,
			},
			{
				MethodName: "WithdrawMarket",
				Handler:    srvCopy.withdrawMarket,
			},
			{
				MethodName: "ListSwaps",
				Handler:    srvCopy.listSwaps,
			},
			{
				MethodName: "ReportMarketFee",
				Handler:    srvCopy.reportMarketFee,
			},
		},
		Streams:  []grpc.StreamDesc{},
		Metadata: "operator.proto",
	}

	s.RegisterService(&sd, nil)
}

// NewOperatorService creates a new OperatorService containing the
// implemented methods of the Operator service in s.  Any unimplemented
// methods will result in the gRPC server returning an UNIMPLEMENTED status to the client.
// This includes situations where the method handler is misspelled or has the wrong
// signature.  For this reason, this function should be used with great care and
// is not recommended to be used by most users.
func NewOperatorService(s interface{}) *OperatorService {
	ns := &OperatorService{}
	if h, ok := s.(interface {
		DepositMarket(context.Context, *DepositMarketRequest) (*DepositMarketReply, error)
	}); ok {
		ns.DepositMarket = h.DepositMarket
	}
	if h, ok := s.(interface {
		ListDepositMarket(context.Context, *ListDepositMarketRequest) (*ListDepositMarketReply, error)
	}); ok {
		ns.ListDepositMarket = h.ListDepositMarket
	}
	if h, ok := s.(interface {
		DepositFeeAccount(context.Context, *DepositFeeAccountRequest) (*DepositFeeAccountReply, error)
	}); ok {
		ns.DepositFeeAccount = h.DepositFeeAccount
	}
	if h, ok := s.(interface {
		BalanceFeeAccount(context.Context, *BalanceFeeAccountRequest) (*BalanceFeeAccountReply, error)
	}); ok {
		ns.BalanceFeeAccount = h.BalanceFeeAccount
	}
	if h, ok := s.(interface {
		OpenMarket(context.Context, *OpenMarketRequest) (*OpenMarketReply, error)
	}); ok {
		ns.OpenMarket = h.OpenMarket
	}
	if h, ok := s.(interface {
		CloseMarket(context.Context, *CloseMarketRequest) (*CloseMarketReply, error)
	}); ok {
		ns.CloseMarket = h.CloseMarket
	}
	if h, ok := s.(interface {
		ListMarket(context.Context, *ListMarketRequest) (*ListMarketReply, error)
	}); ok {
		ns.ListMarket = h.ListMarket
	}
	if h, ok := s.(interface {
		UpdateMarketFee(context.Context, *UpdateMarketFeeRequest) (*UpdateMarketFeeReply, error)
	}); ok {
		ns.UpdateMarketFee = h.UpdateMarketFee
	}
	if h, ok := s.(interface {
		UpdateMarketPrice(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error)
	}); ok {
		ns.UpdateMarketPrice = h.UpdateMarketPrice
	}
	if h, ok := s.(interface {
		UpdateMarketStrategy(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error)
	}); ok {
		ns.UpdateMarketStrategy = h.UpdateMarketStrategy
	}
	if h, ok := s.(interface {
		WithdrawMarket(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error)
	}); ok {
		ns.WithdrawMarket = h.WithdrawMarket
	}
	if h, ok := s.(interface {
		ListSwaps(context.Context, *ListSwapsRequest) (*ListSwapsReply, error)
	}); ok {
		ns.ListSwaps = h.ListSwaps
	}
	if h, ok := s.(interface {
		ReportMarketFee(context.Context, *ReportMarketFeeRequest) (*ReportMarketFeeReply, error)
	}); ok {
		ns.ReportMarketFee = h.ReportMarketFee
	}
	return ns
}

// UnstableOperatorService is the service API for Operator service.
// New methods may be added to this interface if they are added to the service
// definition, which is not a backward-compatible change.  For this reason,
// use of this type is not recommended.
type UnstableOperatorService interface {
	// Returns a new derived address for the given market.
	// If market field is empty, a new Market is created and MUST be initialized.
	DepositMarket(context.Context, *DepositMarketRequest) (*DepositMarketReply, error)
	// Returns the list of previously generated addresses for the given market.
	ListDepositMarket(context.Context, *ListDepositMarketRequest) (*ListDepositMarketReply, error)
	// Returns a new derived address from the fee account.
	// This is only used to deposit some LBTC to subsidize blockchain fees.
	DepositFeeAccount(context.Context, *DepositFeeAccountRequest) (*DepositFeeAccountReply, error)
	// Returns the aggregated balance of LBTC held in the fee account.
	BalanceFeeAccount(context.Context, *BalanceFeeAccountRequest) (*BalanceFeeAccountReply, error)
	// Makes the given market tradable
	OpenMarket(context.Context, *OpenMarketRequest) (*OpenMarketReply, error)
	// Makes the given market NOT tradabale
	CloseMarket(context.Context, *CloseMarketRequest) (*CloseMarketReply, error)
	// Get extended details for each markets either open, closed or to be funded.
	ListMarket(context.Context, *ListMarketRequest) (*ListMarketReply, error)
	// Changes the Liquidity Provider fee for the given market. I thsould be
	// express in basis point. To change the fee on each swap from (current) 0.25%
	// to 1% you need to pass down 100 The Market MUST be closed before doing this
	// change.
	UpdateMarketFee(context.Context, *UpdateMarketFeeRequest) (*UpdateMarketFeeReply, error)
	// Manually updates the price for the given market
	UpdateMarketPrice(context.Context, *UpdateMarketPriceRequest) (*UpdateMarketPriceReply, error)
	// Updates the current market making strategy, either using an automated
	// market making formula or a pluggable price feed
	UpdateMarketStrategy(context.Context, *UpdateMarketStrategyRequest) (*UpdateMarketStrategyReply, error)
	// WithdrawMarket allows the operator to withdraw to external wallet funds
	// from a specific market. The Market MUST be closed before doing this change.
	WithdrawMarket(context.Context, *WithdrawMarketRequest) (*WithdrawMarketReply, error)
	// Returs all the swaps processed by the daemon (both attempted and completed)
	ListSwaps(context.Context, *ListSwapsRequest) (*ListSwapsReply, error)
	// Displays a report on how much the given market is collecting in Liquidity
	// Provider fees
	ReportMarketFee(context.Context, *ReportMarketFeeRequest) (*ReportMarketFeeReply, error)
}
